name: Build Result
# template source: https://github.com/dockersamples/.github/blob/main/templates/call-docker-build.yaml
# added grype, syft, vexctl by vijaykvv on 07-Sep-2025
on:
  # we want pull requests so we can build(test) but not push to image registry
  push:
    branches:
      - 'main'
      - 'sbom'
    # only build when important files change
    paths:
      - 'result/**'
      - '.github/workflows/call-docker-build-result.yaml'
  pull_request:
    branches:
      - 'main'
      - 'sbom'
    # only build when important files change
    paths:
      - 'result/**'
      - '.github/workflows/call-docker-build-result.yaml'

jobs:
  call-docker-build:

    name: Result Call Docker Build

    uses: dockersamples/.github/.github/workflows/reusable-docker-build.yaml@main

    permissions:
      contents: read
      packages: write # needed to push docker image to ghcr.io
      pull-requests: write # needed to create and update comments in PRs
    
    secrets:

      # Only needed if with:dockerhub-enable is true below
      dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}

      # Only needed if with:dockerhub-enable is true below
      dockerhub-token: ${{ secrets.DOCKERHUB_TOKEN }}

    with:
      
      ### REQUIRED
      ### ENABLE ONE OR BOTH REGISTRIES
      ### tell docker where to push.
      ### NOTE if Docker Hub is set to true, you must set secrets above and also add account/repo/tags below
      dockerhub-enable: true
      ghcr-enable: true

      ### REQUIRED 
      ### A list of the account/repo names for docker build. List should match what's enabled above
      ### defaults to:
      image-names: |
        vijaykvv/votingapp_result
      
      ### REQUIRED set rules for tagging images, based on special action syntax:
      ### https://github.com/docker/metadata-action#tags-input
      ### defaults to:
      tag-rules: |
        type=raw,value=latest,enable=${{ endsWith(github.ref, github.event.repository.default_branch) || github.ref == 'refs/heads/sbom' }}
        type=raw,value=latest-${{ github.run_id }}-${{ github.run_number }},enable=${{ endsWith(github.ref, github.event.repository.default_branch) || github.ref == 'refs/heads/sbom' }}
        type=raw,value=${{ github.sha }},enable=${{ endsWith(github.ref, github.event.repository.default_branch) || github.ref == 'refs/heads/sbom' }}
        type=ref,event=pr
      
      ### path to where docker should copy files into image
      ### defaults to root of repository (.)
      context: result
      
      ### Dockerfile alternate name. Default is Dockerfile (relative to context path)
      # file: Containerfile

      ### build stage to target, defaults to empty, which builds to last stage in Dockerfile
      # target:
      
      ### platforms to build for, defaults to linux/amd64
      ### other options: linux/amd64,linux/arm64,linux/arm/v7
      platforms: linux/amd64,linux/arm64,linux/arm/v7
      
      ### Create a PR comment with image tags and labels
      ### defaults to false
      # comment-enable: false

  security-scan:
    needs: call-docker-build
    runs-on: ubuntu-latest
    # Only run on main and sbom branch pushes, not PRs
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/sbom')
    
    permissions:
      contents: write
      packages: write
      id-token: write
      attestations: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GIT_TOKEN }}
      
      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
      - name: Generate timestamp tag
        id: generate-tag
        run: echo "IMAGE_TAG=latest-${{ github.run_id }}-${{ github.run_number }}" >> $GITHUB_OUTPUT
        
      - name: Set image name
        id: image-name
        run: echo "FULL_IMAGE_NAME=vijaykvv/votingapp_result:${{ steps.generate-tag.outputs.IMAGE_TAG }}" >> $GITHUB_OUTPUT
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Pull image for scanning
        run: docker pull ${{ steps.image-name.outputs.FULL_IMAGE_NAME }}
      
      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype version
      
      - name: Install Syft  
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft version
      
      - name: Install VEXctl
        run: |
          curl -sSfL https://github.com/openvex/vexctl/releases/latest/download/vexctl-linux-amd64 -o /usr/local/bin/vexctl
          chmod +x /usr/local/bin/vexctl
          vexctl version
      
      - name: Run Grype vulnerability scan
        run: |
          mkdir -p grype-reports
          grype ${{ steps.image-name.outputs.FULL_IMAGE_NAME }} -o json > grype-reports/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-vulnerabilities.json
          grype ${{ steps.image-name.outputs.FULL_IMAGE_NAME }} -o table > grype-reports/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-vulnerabilities.txt
      
      - name: Generate SBOM with Syft
        run: |
          mkdir -p Image-SBOM-Details
          syft ${{ steps.image-name.outputs.FULL_IMAGE_NAME }} -o cyclonedx-json > Image-SBOM-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-sbom.cyclonedx.json
          syft ${{ steps.image-name.outputs.FULL_IMAGE_NAME }} -o table > Image-SBOM-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-sbom.txt
      
      - name: Generate VEX document from SBOM and Grype results
        run: |
          mkdir -p VEX-Image-Details
          
          # Generate VEX document that cross-references SBOM components
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          from datetime import datetime
          import re
          
          # Read SBOM file (CycloneDX format)
          sbom_file = f"Image-SBOM-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-sbom.cyclonedx.json"
          sbom_components = {}
          
          try:
              with open(sbom_file, 'r') as f:
                  sbom_data = json.load(f)
                  
              # Build component map from SBOM
              for component in sbom_data.get("components", []):
                  name = component.get("name", "")
                  version = component.get("version", "")
                  purl = component.get("purl", "")
                  component_type = component.get("type", "library")
                  
                  # Create searchable keys
                  if name:
                      key = f"{name}@{version}" if version else name
                      sbom_components[key.lower()] = {
                          "name": name,
                          "version": version, 
                          "purl": purl,
                          "type": component_type,
                          "bom_ref": component.get("bom-ref", f"component-{len(sbom_components)}")
                      }
                      
                  # Also index by just name for fuzzy matching
                  if name:
                      sbom_components[name.lower()] = sbom_components[key.lower()]
              
              print(f"Loaded {len(sbom_components)} components from SBOM")
              
          except Exception as e:
              print(f"Could not read SBOM: {e}, proceeding with Grype-only VEX")
              sbom_components = {}
          
          # Read Grype scan results
          grype_file = f"grype-reports/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-vulnerabilities.json"
          
          try:
              with open(grype_file, 'r') as f:
                  grype_data = json.load(f)
          except:
              print("No Grype results found, creating minimal VEX")
              grype_data = {"matches": []}
          
          # Create VEX document structure
          vex_doc = {
              "@context": "https://openvex.dev/ns/v0.2.0",
              "@id": f"https://github.com/vijaykvv/votingapp/vex/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}",
              "author": "GitHub Actions Security Scanner",
              "timestamp": datetime.utcnow().isoformat() + "Z",
              "version": 1,
              "statements": []
          }
          
          # Helper function to find SBOM component
          def find_sbom_component(artifact_name, artifact_version=""):
              if not artifact_name:
                  return None
                  
              # Try exact match with version
              key_with_version = f"{artifact_name}@{artifact_version}".lower() if artifact_version else artifact_name.lower()
              if key_with_version in sbom_components:
                  return sbom_components[key_with_version]
              
              # Try just name
              if artifact_name.lower() in sbom_components:
                  return sbom_components[artifact_name.lower()]
              
              # Try fuzzy matching for similar names
              for comp_key, comp_data in sbom_components.items():
                  if artifact_name.lower() in comp_key or comp_key in artifact_name.lower():
                      return comp_data
              
              return None
          
          # Process vulnerabilities from Grype results
          processed_cves = set()
          
          for match in grype_data.get("matches", []):
              vulnerability = match.get("vulnerability", {})
              cve_id = vulnerability.get("id", "")
              
              # Skip if not a CVE or already processed
              if not cve_id.startswith("CVE-") or cve_id in processed_cves:
                  continue
                  
              processed_cves.add(cve_id)
              
              # Get artifact information
              artifact = match.get("artifact", {})
              artifact_name = artifact.get("name", "unknown-component")
              artifact_version = artifact.get("version", "")
              artifact_type = artifact.get("type", "")
              
              # Find matching SBOM component
              sbom_component = find_sbom_component(artifact_name, artifact_version)
              
              # Determine status based on severity
              severity = vulnerability.get("severity", "Unknown").upper()
              if severity in ["CRITICAL", "HIGH"]:
                  status = "under_investigation"
                  justification = "vulnerability_disputed"
              elif severity in ["MEDIUM"]:
                  status = "not_affected"
                  justification = "vulnerable_code_not_in_execute_path"
              else:
                  status = "not_affected" 
                  justification = "component_not_present"
              
              # Create subcomponent reference
              if sbom_component:
                  # Use SBOM component data for proper traceability
                  subcomponent = {
                      "@id": sbom_component["bom_ref"],
                      "name": sbom_component["name"],
                      "version": sbom_component["version"]
                  }
                  if sbom_component["purl"]:
                      subcomponent["purl"] = sbom_component["purl"]
              else:
                  # Fallback to Grype artifact data
                  subcomponent = {
                      "@id": f"component-{artifact_name}-{artifact_version}",
                      "name": artifact_name
                  }
                  if artifact_version:
                      subcomponent["version"] = artifact_version
              
              # Create VEX statement with SBOM linkage
              statement = {
                  "vulnerability": {
                      "name": cve_id,
                      "description": vulnerability.get("description", f"Vulnerability {cve_id}")
                  },
                  "products": [
                      {
                          "@id": "${{ steps.image-name.outputs.FULL_IMAGE_NAME }}",
                          "subcomponents": [subcomponent]
                      }
                  ],
                  "status": status,
                  "justification": justification,
                  "impact_statement": f"Severity: {severity} - {vulnerability.get('description', 'No description available')}",
                  "action_statement": f"Component {'found in SBOM' if sbom_component else 'detected by scanner'}: {artifact_name}"
              }
              
              vex_doc["statements"].append(statement)
          
          # If no vulnerabilities found, create statement for all SBOM components
          if not vex_doc["statements"]:
              # Create a comprehensive clean scan statement
              clean_components = []
              for comp_key, comp_data in list(sbom_components.items())[:10]:  # Limit to first 10 for brevity
                  clean_components.append({
                      "@id": comp_data["bom_ref"],
                      "name": comp_data["name"],
                      "version": comp_data["version"]
                  })
              
              vex_doc["statements"].append({
                  "vulnerability": {
                      "name": "SCAN-COMPLETE",
                      "description": "Security scan completed with no vulnerabilities found"
                  },
                  "products": [
                      {
                          "@id": "${{ steps.image-name.outputs.FULL_IMAGE_NAME }}",
                          "subcomponents": clean_components if clean_components else [{"@id": "image-root"}]
                      }
                  ],
                  "status": "not_affected",
                  "justification": "component_not_present",
                  "impact_statement": f"No known vulnerabilities detected in this image with {len(sbom_components)} components scanned",
                  "action_statement": f"All components from SBOM verified clean by Grype scanner"
              })
          
          # Write VEX document
          vex_file = f"VEX-Image-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-vex.json"
          with open(vex_file, 'w') as f:
              json.dump(vex_doc, f, indent=2)
              
          print(f"Generated SBOM-linked VEX document with {len(vex_doc['statements'])} statements")
          print(f"SBOM components referenced: {len([s for s in vex_doc['statements'] if any('bom_ref' in str(sc) for sc in s.get('products', [{}])[0].get('subcomponents', []))])}")
          PYTHON_SCRIPT
      
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.4'
      
      - name: Attest SBOM to image
        run: |
          cosign attest --predicate Image-SBOM-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-sbom.cyclonedx.json \
            --type cyclonedx \
            --yes \
            ${{ steps.image-name.outputs.FULL_IMAGE_NAME }}
        env:
          COSIGN_EXPERIMENTAL: 1
      
      - name: Attest VEX to image  
        run: |
          cosign attest --predicate VEX-Image-Details/votingapp_result-${{ steps.generate-tag.outputs.IMAGE_TAG }}-vex.json \
            --type vuln \
            --yes \
            ${{ steps.image-name.outputs.FULL_IMAGE_NAME }}
        env:
          COSIGN_EXPERIMENTAL: 1
      
      - name: Commit and push security artifacts (SBOM, VEX, Grype reports)
        run: |
          # Retry logic for git push with proper conflict resolution
          for i in {1..5}; do
            git pull origin ${{ github.ref_name }} || true
            git add Image-SBOM-Details/ VEX-Image-Details/ grype-reports/
            if git commit -m "Add SBOM, VEX, and vulnerability reports for votingapp_result:${{ steps.generate-tag.outputs.IMAGE_TAG }}"; then
              if git push origin ${{ github.ref_name }}; then
                echo "Successfully pushed on attempt $i"
                break
              else
                echo "Push failed on attempt $i, retrying..."
                git pull --rebase origin ${{ github.ref_name }} || true
                sleep $((i * 2))
              fi
            else
              echo "No changes to commit"
              break
            fi
          done

  update-manifests:
    needs: call-docker-build
    runs-on: ubuntu-latest
    # Only run on main and sbom branch pushes, not PRs
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/sbom')
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
      - name: Fetch latest changes
        run: |
          git pull origin main
      
      - name: Generate timestamp tag
        id: generate-tag
        run: echo "IMAGE_TAG=latest-${{ github.run_id }}-${{ github.run_number }}" >> $GITHUB_OUTPUT
      
      - name: Update Kubernetes manifests
        run: |
          # First reset any previous tags to latest
          sed -i "s|vijaykvv/votingapp_result:latest-.*|vijaykvv/votingapp_result:latest|g" k8s-specifications/result-deployment.yaml
          
          # Then update to the new tag
          sed -i "s|vijaykvv/votingapp_result:latest|vijaykvv/votingapp_result:${{ steps.generate-tag.outputs.IMAGE_TAG }}|g" k8s-specifications/result-deployment.yaml
          
      - name: Commit and push changes
        run: |
          # Retry logic for git push with proper conflict resolution
          for i in {1..5}; do
            git pull origin ${{ github.ref_name }} || true
            git add k8s-specifications/result-deployment.yaml
            if git commit -m "Update result image to ${{ steps.generate-tag.outputs.IMAGE_TAG }}"; then
              if git push origin ${{ github.ref_name }}; then
                echo "Successfully pushed manifest update on attempt $i"
                break
              else
                echo "Manifest push failed on attempt $i, retrying..."
                git pull --rebase origin ${{ github.ref_name }} || true
                sleep $((i * 2))
              fi
            else
              echo "No manifest changes to commit"
              break
            fi
          done
